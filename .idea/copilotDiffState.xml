<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/design_patterns.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/design_patterns.h" />
              <option name="updatedContent" value="//&#10;// Created for OOP Project - Design Patterns&#10;//&#10;&#10;#ifndef ARRC_DESIGN_PATTERNS_H&#10;#define ARRC_DESIGN_PATTERNS_H&#10;&#10;#include &lt;string&gt;&#10;#include &lt;map&gt;&#10;#include &lt;list&gt;&#10;#include &lt;memory&gt;&#10;#include &lt;functional&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;numeric&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;iostream&gt;&#10;#include &quot;tensor_initializer.h&quot;&#10;&#10;// Forward declarations&#10;template &lt;typename dtype&gt;&#10;class NDArray;&#10;&#10;/// ===========================================&#10;/// DESIGN PATTERN 1: SINGLETON&#10;/// CudaDeviceManager - gestionează device-ul CUDA&#10;/// ===========================================&#10;class CudaDeviceManager {&#10;private:&#10;    int currentDevice;&#10;    int deviceCount;&#10;    bool initialized;&#10;    &#10;    // Constructor privat - Singleton&#10;    CudaDeviceManager() : currentDevice(0), deviceCount(0), initialized(false) {&#10;        initialize();&#10;    }&#10;    &#10;    // Delete copy constructor și assignment - Singleton&#10;    CudaDeviceManager(const CudaDeviceManager&amp;) = delete;&#10;    CudaDeviceManager&amp; operator=(const CudaDeviceManager&amp;) = delete;&#10;    &#10;    void initialize() {&#10;        cudaGetDeviceCount(&amp;deviceCount);&#10;        if (deviceCount &gt; 0) {&#10;            cudaSetDevice(0);&#10;            initialized = true;&#10;        }&#10;    }&#10;    &#10;public:&#10;    // Singleton getInstance&#10;    static CudaDeviceManager&amp; getInstance() {&#10;        static CudaDeviceManager instance;&#10;        return instance;&#10;    }&#10;    &#10;    int getDeviceCount() const { return deviceCount; }&#10;    int getCurrentDevice() const { return currentDevice; }&#10;    bool isInitialized() const { return initialized; }&#10;    &#10;    bool setDevice(int deviceId) {&#10;        if (deviceId &gt;= 0 &amp;&amp; deviceId &lt; deviceCount) {&#10;            cudaSetDevice(deviceId);&#10;            currentDevice = deviceId;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;    &#10;    std::string getDeviceName() const {&#10;        if (!initialized) return &quot;No CUDA device&quot;;&#10;        cudaDeviceProp prop;&#10;        cudaGetDeviceProperties(&amp;prop, currentDevice);&#10;        return std::string(prop.name);&#10;    }&#10;    &#10;    size_t getFreeMemory() const {&#10;        size_t free, total;&#10;        cudaMemGetInfo(&amp;free, &amp;total);&#10;        return free;&#10;    }&#10;    &#10;    size_t getTotalMemory() const {&#10;        size_t free, total;&#10;        cudaMemGetInfo(&amp;free, &amp;total);&#10;        return total;&#10;    }&#10;    &#10;    void synchronize() const {&#10;        cudaDeviceSynchronize();&#10;    }&#10;};&#10;&#10;&#10;/// ===========================================&#10;/// DESIGN PATTERN 2: FACTORY&#10;/// TensorFactory - creează tensori cu diferite inițializări&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class TensorFactory {&#10;private:&#10;    // Map pentru înregistrarea tipurilor de inițializări&#10;    // Folosește std::map - al doilea container STL!&#10;    static std::map&lt;std::string, std::function&lt;dtype(int, int)&gt;&gt; initializerRegistry;&#10;    &#10;    // Static counter&#10;    static int tensorsCreated;&#10;    &#10;public:&#10;    // Înregistrează un nou tip de inițializare&#10;    static void registerInitializer(const std::string&amp; name, &#10;                                    std::function&lt;dtype(int, int)&gt; func) {&#10;        initializerRegistry[name] = func;&#10;    }&#10;    &#10;    // Creează tensor cu tip înregistrat&#10;    static NDArray&lt;dtype&gt; create(const std::vector&lt;int&gt;&amp; shape, &#10;                                  const std::string&amp; initType = &quot;zeros&quot;) {&#10;        NDArray&lt;dtype&gt; result(shape);&#10;        &#10;        auto it = initializerRegistry.find(initType);&#10;        if (it != initializerRegistry.end()) {&#10;            int size = result.getSize();&#10;            // Folosim algoritm STL cu lambda!&#10;            std::vector&lt;int&gt; indices(size);&#10;            std::iota(indices.begin(), indices.end(), 0);  // 0, 1, 2, ...&#10;            &#10;            std::for_each(indices.begin(), indices.end(), &#10;                [&amp;result, &amp;it, size](int idx) {&#10;                    // Calculăm indexul multi-dimensional&#10;                    std::vector&lt;int&gt; shp = result.getShape();&#10;                    std::vector&lt;int&gt; multiIdx(shp.size());&#10;                    int remaining = idx;&#10;                    for (int d = static_cast&lt;int&gt;(shp.size()) - 1; d &gt;= 0; d--) {&#10;                        multiIdx[d] = remaining % shp[d];&#10;                        remaining /= shp[d];&#10;                    }&#10;                    result[multiIdx] = it-&gt;second(idx, size);&#10;                });&#10;        }&#10;        &#10;        ++tensorsCreated;&#10;        return result;&#10;    }&#10;    &#10;    // Factory methods convenabile&#10;    static NDArray&lt;dtype&gt; zeros(const std::vector&lt;int&gt;&amp; shape) {&#10;        return create(shape, &quot;zeros&quot;);&#10;    }&#10;    &#10;    static NDArray&lt;dtype&gt; ones(const std::vector&lt;int&gt;&amp; shape) {&#10;        return create(shape, &quot;ones&quot;);&#10;    }&#10;    &#10;    static NDArray&lt;dtype&gt; arange(const std::vector&lt;int&gt;&amp; shape) {&#10;        return create(shape, &quot;arange&quot;);&#10;    }&#10;    &#10;    static int getTensorsCreated() { return tensorsCreated; }&#10;    &#10;    // Inițializare registry-ul default&#10;    static void initializeDefaults() {&#10;        registerInitializer(&quot;zeros&quot;, [](int, int) -&gt; dtype { return 0; });&#10;        registerInitializer(&quot;ones&quot;, [](int, int) -&gt; dtype { return 1; });&#10;        registerInitializer(&quot;arange&quot;, [](int idx, int) -&gt; dtype { &#10;            return static_cast&lt;dtype&gt;(idx); &#10;        });&#10;    }&#10;};&#10;&#10;template &lt;typename dtype&gt;&#10;std::map&lt;std::string, std::function&lt;dtype(int, int)&gt;&gt; TensorFactory&lt;dtype&gt;::initializerRegistry;&#10;&#10;template &lt;typename dtype&gt;&#10;int TensorFactory&lt;dtype&gt;::tensorsCreated = 0;&#10;&#10;&#10;/// ===========================================&#10;/// DESIGN PATTERN 3: OBSERVER (opțional, pentru bonus)&#10;/// TensorObserver - notifică când se modifică un tensor&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class TensorObserver {&#10;public:&#10;    virtual ~TensorObserver() = default;&#10;    virtual void onTensorModified(const std::string&amp; operationType) = 0;&#10;};&#10;&#10;template &lt;typename dtype&gt;&#10;class TensorLogger : public TensorObserver&lt;dtype&gt; {&#10;private:&#10;    // std::list - al doilea container STL!&#10;    std::list&lt;std::string&gt; operationLog;&#10;    static const int MAX_LOG_SIZE = 100;&#10;    &#10;public:&#10;    void onTensorModified(const std::string&amp; operationType) override {&#10;        operationLog.push_back(operationType);&#10;        if (operationLog.size() &gt; MAX_LOG_SIZE) {&#10;            operationLog.pop_front();&#10;        }&#10;    }&#10;    &#10;    void printLog() const {&#10;        std::cout &lt;&lt; &quot;=== Tensor Operation Log ===&quot; &lt;&lt; std::endl;&#10;        for (const auto&amp; op : operationLog) {&#10;            std::cout &lt;&lt; &quot;  - &quot; &lt;&lt; op &lt;&lt; std::endl;&#10;        }&#10;    }&#10;    &#10;    const std::list&lt;std::string&gt;&amp; getLog() const { return operationLog; }&#10;    void clearLog() { operationLog.clear(); }&#10;};&#10;&#10;&#10;/// ===========================================&#10;/// HELPER: demonstrează upcast și downcast&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;void demonstratePolymorphism(TensorInitializer&lt;dtype&gt;* basePtr) {&#10;    // UPCAST implicit - pointer la bază&#10;    std::cout &lt;&lt; &quot;Using base pointer: &quot; &lt;&lt; *basePtr &lt;&lt; std::endl;&#10;    &#10;    // DOWNCAST cu dynamic_cast&#10;    if (auto* zerosPtr = dynamic_cast&lt;ZerosInitializer&lt;dtype&gt;*&gt;(basePtr)) {&#10;        std::cout &lt;&lt; &quot;  -&gt; Downcast to ZerosInitializer successful!&quot; &lt;&lt; std::endl;&#10;        std::cout &lt;&lt; &quot;  -&gt; Value at index 5: &quot; &lt;&lt; zerosPtr-&gt;getValue(5, 10) &lt;&lt; std::endl;&#10;    } else if (auto* rangePtr = dynamic_cast&lt;RangeInitializer&lt;dtype&gt;*&gt;(basePtr)) {&#10;        std::cout &lt;&lt; &quot;  -&gt; Downcast to RangeInitializer successful!&quot; &lt;&lt; std::endl;&#10;        std::cout &lt;&lt; &quot;  -&gt; Value at index 5: &quot; &lt;&lt; rangePtr-&gt;getValue(5, 10) &lt;&lt; std::endl;&#10;    } else if (auto* randomPtr = dynamic_cast&lt;RandomInitializer&lt;dtype&gt;*&gt;(basePtr)) {&#10;        std::cout &lt;&lt; &quot;  -&gt; Downcast to RandomInitializer successful!&quot; &lt;&lt; std::endl;&#10;        std::cout &lt;&lt; &quot;  -&gt; Random value: &quot; &lt;&lt; randomPtr-&gt;getValue(0, 10) &lt;&lt; std::endl;&#10;    } else if (auto* onesPtr = dynamic_cast&lt;OnesInitializer&lt;dtype&gt;*&gt;(basePtr)) {&#10;        std::cout &lt;&lt; &quot;  -&gt; Downcast to OnesInitializer successful!&quot; &lt;&lt; std::endl;&#10;        std::cout &lt;&lt; &quot;  -&gt; Value at index 5: &quot; &lt;&lt; onesPtr-&gt;getValue(5, 10) &lt;&lt; std::endl;&#10;    }&#10;}&#10;&#10;&#10;#endif // ARRC_DESIGN_PATTERNS_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tensor_initializer.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tensor_initializer.h" />
              <option name="updatedContent" value="//&#10;// Created for OOP Project - Abstract Class + Derived Classes&#10;//&#10;&#10;#ifndef ARRC_TENSOR_INITIALIZER_H&#10;#define ARRC_TENSOR_INITIALIZER_H&#10;&#10;#include &lt;string&gt;&#10;#include &lt;random&gt;&#10;#include &lt;ctime&gt;&#10;#include &lt;iostream&gt;&#10;&#10;// Forward declaration&#10;template &lt;typename dtype&gt;&#10;class NDArray;&#10;&#10;/// ===========================================&#10;/// CLASĂ ABSTRACTĂ - TensorInitializer&#10;/// Definește interfața pentru inițializarea tensorilor&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class TensorInitializer {&#10;protected:&#10;    std::string name;&#10;    &#10;    // Static counter pentru tracking&#10;    static int initializerCount;&#10;    &#10;public:&#10;    // Constructor&#10;    explicit TensorInitializer(const std::string&amp; name) : name(name) {&#10;        ++initializerCount;&#10;    }&#10;    &#10;    // Destructor VIRTUAL - esențial pentru ierarhii de clase&#10;    virtual ~TensorInitializer() {&#10;        --initializerCount;&#10;    }&#10;    &#10;    // Copy constructor&#10;    TensorInitializer(const TensorInitializer&amp; other) : name(other.name) {&#10;        ++initializerCount;&#10;    }&#10;    &#10;    // Copy assignment&#10;    TensorInitializer&amp; operator=(const TensorInitializer&amp; other) {&#10;        if (this != &amp;other) {&#10;            name = other.name;&#10;        }&#10;        return *this;&#10;    }&#10;    &#10;    // ============ METODE VIRTUALE PURE (clasă abstractă) ============&#10;    virtual dtype getValue(int index, int size) const = 0;&#10;    virtual std::string getDescription() const = 0;&#10;    &#10;    // Getters&#10;    std::string getName() const { return name; }&#10;    &#10;    // Static function&#10;    static int getInitializerCount() { return initializerCount; }&#10;    &#10;    // Operator&lt;&lt; ca friend (non-member)&#10;    template &lt;typename T&gt;&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const TensorInitializer&lt;T&gt;&amp; init);&#10;};&#10;&#10;template &lt;typename dtype&gt;&#10;int TensorInitializer&lt;dtype&gt;::initializerCount = 0;&#10;&#10;// Operator&lt;&lt; non-member friend&#10;template &lt;typename dtype&gt;&#10;std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const TensorInitializer&lt;dtype&gt;&amp; init) {&#10;    os &lt;&lt; &quot;[Initializer: &quot; &lt;&lt; init.name &lt;&lt; &quot;] &quot; &lt;&lt; init.getDescription();&#10;    return os;&#10;}&#10;&#10;/// ===========================================&#10;/// CLASĂ DERIVATĂ 1 - ZerosInitializer&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class ZerosInitializer : public TensorInitializer&lt;dtype&gt; {&#10;public:&#10;    ZerosInitializer() : TensorInitializer&lt;dtype&gt;(&quot;Zeros&quot;) {}&#10;    &#10;    // Copy constructor - apelează constructorul bazei&#10;    ZerosInitializer(const ZerosInitializer&amp; other) : TensorInitializer&lt;dtype&gt;(other) {}&#10;    &#10;    // Copy assignment&#10;    ZerosInitializer&amp; operator=(const ZerosInitializer&amp; other) {&#10;        if (this != &amp;other) {&#10;            TensorInitializer&lt;dtype&gt;::operator=(other);&#10;        }&#10;        return *this;&#10;    }&#10;    &#10;    dtype getValue(int index, int size) const override {&#10;        (void)index; (void)size;  // unused&#10;        return static_cast&lt;dtype&gt;(0);&#10;    }&#10;    &#10;    std::string getDescription() const override {&#10;        return &quot;Initializes all elements to zero&quot;;&#10;    }&#10;};&#10;&#10;/// ===========================================&#10;/// CLASĂ DERIVATĂ 2 - OnesInitializer&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class OnesInitializer : public TensorInitializer&lt;dtype&gt; {&#10;public:&#10;    OnesInitializer() : TensorInitializer&lt;dtype&gt;(&quot;Ones&quot;) {}&#10;    &#10;    OnesInitializer(const OnesInitializer&amp; other) : TensorInitializer&lt;dtype&gt;(other) {}&#10;    &#10;    OnesInitializer&amp; operator=(const OnesInitializer&amp; other) {&#10;        if (this != &amp;other) {&#10;            TensorInitializer&lt;dtype&gt;::operator=(other);&#10;        }&#10;        return *this;&#10;    }&#10;    &#10;    dtype getValue(int index, int size) const override {&#10;        (void)index; (void)size;&#10;        return static_cast&lt;dtype&gt;(1);&#10;    }&#10;    &#10;    std::string getDescription() const override {&#10;        return &quot;Initializes all elements to one&quot;;&#10;    }&#10;};&#10;&#10;/// ===========================================&#10;/// CLASĂ DERIVATĂ 3 - RangeInitializer (arange)&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class RangeInitializer : public TensorInitializer&lt;dtype&gt; {&#10;private:&#10;    dtype start;&#10;    dtype step;&#10;    &#10;public:&#10;    RangeInitializer(dtype start = 0, dtype step = 1) &#10;        : TensorInitializer&lt;dtype&gt;(&quot;Range&quot;), start(start), step(step) {}&#10;    &#10;    RangeInitializer(const RangeInitializer&amp; other) &#10;        : TensorInitializer&lt;dtype&gt;(other), start(other.start), step(other.step) {}&#10;    &#10;    RangeInitializer&amp; operator=(const RangeInitializer&amp; other) {&#10;        if (this != &amp;other) {&#10;            TensorInitializer&lt;dtype&gt;::operator=(other);&#10;            start = other.start;&#10;            step = other.step;&#10;        }&#10;        return *this;&#10;    }&#10;    &#10;    dtype getValue(int index, int size) const override {&#10;        (void)size;&#10;        return start + static_cast&lt;dtype&gt;(index) * step;&#10;    }&#10;    &#10;    std::string getDescription() const override {&#10;        return &quot;Initializes elements as arithmetic sequence&quot;;&#10;    }&#10;};&#10;&#10;// Operator== non-membru (NU friend) - cerință din laborator&#10;template &lt;typename dtype&gt;&#10;bool operator==(const RangeInitializer&lt;dtype&gt;&amp; a, const RangeInitializer&lt;dtype&gt;&amp; b) {&#10;    return a.getName() == b.getName();&#10;}&#10;&#10;template &lt;typename dtype&gt;&#10;bool operator!=(const RangeInitializer&lt;dtype&gt;&amp; a, const RangeInitializer&lt;dtype&gt;&amp; b) {&#10;    return !(a == b);&#10;}&#10;&#10;&#10;/// ===========================================&#10;/// CLASĂ DERIVATĂ 4 - RandomInitializer&#10;/// ===========================================&#10;template &lt;typename dtype&gt;&#10;class RandomInitializer : public TensorInitializer&lt;dtype&gt; {&#10;private:&#10;    dtype minVal;&#10;    dtype maxVal;&#10;    mutable std::mt19937 generator;  // mutable pentru getValue const&#10;    &#10;public:&#10;    RandomInitializer(dtype minVal = 0, dtype maxVal = 1) &#10;        : TensorInitializer&lt;dtype&gt;(&quot;Random&quot;), &#10;          minVal(minVal), maxVal(maxVal),&#10;          generator(static_cast&lt;unsigned&gt;(std::time(nullptr))) {}&#10;    &#10;    RandomInitializer(const RandomInitializer&amp; other) &#10;        : TensorInitializer&lt;dtype&gt;(other), &#10;          minVal(other.minVal), maxVal(other.maxVal),&#10;          generator(static_cast&lt;unsigned&gt;(std::time(nullptr))) {}&#10;    &#10;    RandomInitializer&amp; operator=(const RandomInitializer&amp; other) {&#10;        if (this != &amp;other) {&#10;            TensorInitializer&lt;dtype&gt;::operator=(other);&#10;            minVal = other.minVal;&#10;            maxVal = other.maxVal;&#10;        }&#10;        return *this;&#10;    }&#10;    &#10;    dtype getValue(int index, int size) const override {&#10;        (void)index; (void)size;&#10;        std::uniform_real_distribution&lt;double&gt; dist(&#10;            static_cast&lt;double&gt;(minVal), &#10;            static_cast&lt;double&gt;(maxVal)&#10;        );&#10;        return static_cast&lt;dtype&gt;(dist(generator));&#10;    }&#10;    &#10;    std::string getDescription() const override {&#10;        return &quot;Initializes elements with random values&quot;;&#10;    }&#10;};&#10;&#10;&#10;#endif // ARRC_TENSOR_INITIALIZER_H&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>